// Generated using `moon info`, DON'T EDIT IT
package "Milky2018/moon_cosmic"

import {
  "Milky2018/moon_swash",
  "Milky2018/moon_swash/scale",
  "Milky2018/moon_zeno",
  "moonbitlang/core/hashmap",
}

// Values
pub const CACHE_KEY_FLAG_DISABLE_HINTING : UInt = 2

pub const CACHE_KEY_FLAG_FAKE_ITALIC : UInt = 1

pub const CACHE_KEY_FLAG_PIXEL_FONT : UInt = 4

pub fn apply_align(String, Array[LayoutLine], Float, Align) -> Array[LayoutLine]

pub fn apply_align_with_rtl(String, Array[LayoutLine], Float, Align, Bool) -> Array[LayoutLine]

pub fn cosmic_text_version() -> String

pub fn floorf(Float) -> Float

pub fn grapheme_indices_uax29(String) -> Array[(Int, Int)]

pub fn justify_to_align(Justify) -> Align

pub fn layout_ascii(String, Float, Float?, Wrap) -> Array[LayoutLine]

pub fn layout_from_shape(String, ShapeLine, Float, Float, Float?, Wrap) -> Array[LayoutLine]

pub fn line_break_to_wrap(LineBreak) -> Wrap

pub fn roundf(Float) -> Float

pub fn truncf(Float) -> Float

pub fn word_indices_uax29(String) -> Array[(Int, Int)]

pub fn word_indices_whitespace(String) -> Array[(Int, Int)]

pub fn wrap_word_segments(String) -> Array[(Int, Int, Bool)]

// Errors

// Types and methods
pub(all) enum Action {
  Motion(Motion)
  Escape
  Insert(Char)
  Enter
  Backspace
  Delete
  Indent
  Unindent
  Click(Int, Int)
  DoubleClick(Int, Int)
  TripleClick(Int, Int)
  Drag(Int, Int)
  Scroll(Float)
}

pub(all) enum Affinity {
  Before
  After
}
pub fn Affinity::after(Self) -> Bool
pub fn Affinity::before(Self) -> Bool
pub fn Affinity::from_after(Bool) -> Self
pub fn Affinity::from_before(Bool) -> Self
pub impl Eq for Affinity

pub(all) enum Align {
  Left
  Right
  Center
  Justified
  End
}

pub struct Attrs {
  metadata : Int
  family : Family
  weight : Weight
  stretch : @moon_swash.Stretch
  style : @moon_swash.Style
  metrics_opt : CacheMetrics?
}
pub fn Attrs::family(Self, Family) -> Self
pub fn Attrs::family_value(Self) -> Family
pub fn Attrs::metadata(Self) -> Int
pub fn Attrs::metrics(Self, Metrics) -> Self
pub fn Attrs::metrics_opt(Self) -> Metrics?
pub fn Attrs::new() -> Self
pub fn Attrs::stretch(Self, @moon_swash.Stretch) -> Self
pub fn Attrs::stretch_value(Self) -> @moon_swash.Stretch
pub fn Attrs::style(Self, @moon_swash.Style) -> Self
pub fn Attrs::style_value(Self) -> @moon_swash.Style
pub fn Attrs::weight(Self, Weight) -> Self
pub fn Attrs::weight_value(Self) -> Weight
pub fn Attrs::with_metadata(Int) -> Self
pub impl Eq for Attrs
pub impl Hash for Attrs

pub struct AttrsList {
  defaults : Attrs
  spans : Array[AttrsSpan]
}
pub fn AttrsList::add_span(Self, Int, Int, Attrs) -> Self
pub fn AttrsList::defaults(Self) -> Attrs
pub fn AttrsList::eq(Self, Self) -> Bool
pub fn AttrsList::get_span(Self, Int) -> Attrs
pub fn AttrsList::new(Attrs) -> Self
pub fn AttrsList::spans_iter(Self) -> Array[AttrsSpan]
pub fn AttrsList::split_off(Self, Int) -> (Self, Self)
pub impl Eq for AttrsList
pub impl Hash for AttrsList

pub struct AttrsSpan {
  start : Int
  end : Int
  attrs : Attrs
}
pub impl Eq for AttrsSpan
pub impl Hash for AttrsSpan

pub struct BidiParagraphs {
  text : String
  pos : Int
  ascii_fast : Bool
}
pub fn BidiParagraphs::iter(Self) -> Iter[String]
pub fn BidiParagraphs::new(String) -> Self
pub fn BidiParagraphs::next(Self) -> (Self, String)?

pub struct Buffer {
  lines : Array[BufferLine]
  metrics : Metrics
  width_opt : Float?
  height_opt : Float?
  scroll : Scroll
  redraw : Bool
  wrap : Wrap
  monospace_width : Float?
  tab_width : Int
  hinting : Hinting
}
pub fn Buffer::cursor_motion(Self, Cursor, Int?, Motion) -> (Cursor, Int?)?
pub fn Buffer::draw(Self, FontSystem, SwashCache, Color, (Int, Int, UInt, UInt, Color) -> Unit) -> (Self, SwashCache)
pub fn Buffer::draw_with_font_system(Self, FontSystem, SwashCache, Color, (Int, Int, UInt, UInt, Color) -> Unit) -> (Self, SwashCache)
pub fn Buffer::hinting(Self) -> Hinting
pub fn Buffer::hit(Self, Float, Float) -> Cursor?
pub fn Buffer::layout_all(Self) -> Self
pub fn Buffer::layout_all_with_font_system(Self, FontSystem) -> Self
pub fn Buffer::layout_runs(Self) -> Iter[LayoutRun]
pub fn Buffer::lines(Self) -> Array[BufferLine]
pub fn Buffer::metrics(Self) -> Metrics
pub fn Buffer::new(Metrics) -> Self
pub fn Buffer::new_empty(Metrics) -> Self
pub fn Buffer::redraw(Self) -> Bool
pub fn Buffer::scroll(Self) -> Scroll
pub fn Buffer::set_hinting(Self, Hinting) -> Self
pub fn Buffer::set_metrics(Self, Metrics) -> Self
pub fn Buffer::set_monospace_width(Self, Float?) -> Self
pub fn Buffer::set_redraw(Self, Bool) -> Self
pub fn Buffer::set_rich_text(Self, Array[(String, Attrs)], Attrs, Shaping, Align?) -> Self
pub fn Buffer::set_scroll(Self, Scroll) -> Self
pub fn Buffer::set_size(Self, Float?, Float?) -> Self
pub fn Buffer::set_tab_width(Self, Int) -> Self
pub fn Buffer::set_text(Self, String, AttrsList, Shaping) -> Self
pub fn Buffer::set_wrap(Self, Wrap) -> Self
pub fn Buffer::shape_all_with_font_system(Self, FontSystem) -> Self
pub fn Buffer::size(Self) -> (Float?, Float?)
pub fn Buffer::wrap(Self) -> Wrap

pub struct BufferLine {
  text : String
  ending : LineEnding
  attrs_list : AttrsList
  align : Align?
  shape_opt : Cached[ShapeLine]
  layout_opt : Cached[Array[LayoutLine]]
  shaping : Shaping
  metadata : Int?
}
pub fn BufferLine::align(Self) -> Align?
pub fn BufferLine::append(Self, Self) -> Self
pub fn BufferLine::attrs_list(Self) -> AttrsList
pub fn BufferLine::ending(Self) -> LineEnding
pub fn BufferLine::layout(Self, Float, Float?, Wrap, Float?, Int, Hinting) -> Self
pub fn BufferLine::layout_opt(Self) -> Array[LayoutLine]?
pub fn BufferLine::layout_with_font_system(Self, FontSystem, Float, Float?, Wrap, Float?, Int, Hinting) -> Self
pub fn BufferLine::new(String, LineEnding, AttrsList, Shaping) -> Self
pub fn BufferLine::reset(Self) -> Self
pub fn BufferLine::reset_layout(Self) -> Self
pub fn BufferLine::reset_shaping(Self) -> Self
pub fn BufferLine::set_align(Self, Align?) -> (Self, Bool)
pub fn BufferLine::set_ending(Self, LineEnding) -> Self
pub fn BufferLine::set_text(Self, String, LineEnding, AttrsList) -> (Self, Bool)
pub fn BufferLine::shape(Self, Int) -> Self
pub fn BufferLine::shape_opt(Self) -> ShapeLine?
pub fn BufferLine::shape_with_font_system(Self, FontSystem, Int) -> Self
pub fn BufferLine::split_off(Self, Int) -> (Self, Self)
pub fn BufferLine::text(Self) -> String

pub struct CacheKey {
  font_id : Int
  glyph_id : Int
  font_size_bits : UInt
  x_bin : SubpixelBin
  y_bin : SubpixelBin
  font_weight : Int
  flags : UInt
}
pub fn CacheKey::has_disable_hinting(Self) -> Bool
pub fn CacheKey::has_fake_italic(Self) -> Bool
pub fn CacheKey::has_pixel_font(Self) -> Bool
pub fn CacheKey::new(Int, Int, Float, (Float, Float), Int, UInt) -> (Self, Int, Int)
pub fn CacheKey::x_bin(Self) -> SubpixelBin
pub fn CacheKey::y_bin(Self) -> SubpixelBin
pub impl Eq for CacheKey
pub impl Hash for CacheKey
pub impl Show for CacheKey

pub struct CacheMetrics {
  font_size_bits : UInt
  line_height_bits : UInt
}
pub fn CacheMetrics::font_size(Self) -> Float
pub fn CacheMetrics::from_metrics(Metrics) -> Self
pub fn CacheMetrics::line_height(Self) -> Float
pub fn CacheMetrics::to_metrics(Self) -> Metrics
pub impl Eq for CacheMetrics
pub impl Hash for CacheMetrics
pub impl Show for CacheMetrics

pub(all) enum Cached[T] {
  Empty
  Unused(T)
  Used(T)
}
pub fn[T] Cached::get(Self[T]) -> T?
pub fn[T] Cached::is_unused(Self[T]) -> Bool
pub fn[T] Cached::is_used(Self[T]) -> Bool
pub fn[T] Cached::set_unused(Self[T]) -> Self[T]
pub fn[T] Cached::set_used(Self[T], T) -> Self[T]
pub fn[T] Cached::take_unused(Self[T]) -> (Self[T], T?)
pub fn[T] Cached::take_used(Self[T]) -> (Self[T], T?)

pub(all) struct Change {
  items : Array[ChangeItem]
}
pub fn Change::default() -> Self
pub fn Change::reverse(Self) -> Self

pub(all) struct ChangeItem {
  start : Cursor
  end : Cursor
  text : String
  insert : Bool
}
pub fn ChangeItem::reverse(Self) -> Self

pub struct Color {
  value : UInt
}
pub fn Color::a(Self) -> Byte
pub fn Color::as_rgba(Self) -> (Byte, Byte, Byte, Byte)
pub fn Color::b(Self) -> Byte
pub fn Color::g(Self) -> Byte
pub fn Color::r(Self) -> Byte
pub fn Color::rgb(Byte, Byte, Byte) -> Self
pub fn Color::rgba(Byte, Byte, Byte, Byte) -> Self
pub impl Eq for Color

pub struct Cursor {
  line : Int
  index : Int
  affinity : Affinity
}
pub fn Cursor::new(Int, Int) -> Self
pub fn Cursor::new_with_affinity(Int, Int, Affinity) -> Self
pub impl Eq for Cursor

pub struct Editor {
  buffer : Buffer
  cursor : Cursor
  cursor_x_opt : Int?
  selection : Selection
  cursor_moved : Bool
  auto_indent : Bool
  change_opt : Change?
}
pub fn Editor::action(Self, Action) -> Self
pub fn Editor::apply_change(Self, Change) -> (Self, Bool)
pub fn Editor::auto_indent(Self) -> Bool
pub fn Editor::buffer(Self) -> Buffer
pub fn Editor::copy_selection(Self) -> String?
pub fn Editor::cursor(Self) -> Cursor
pub fn Editor::cursor_position(Self) -> (Int, Int)?
pub fn Editor::delete_range(Self, Cursor, Cursor) -> Self
pub fn Editor::delete_selection(Self) -> (Self, Bool)
pub fn Editor::finish_change(Self) -> (Self, Change?)
pub fn Editor::insert_at(Self, Cursor, String, AttrsList?) -> (Self, Cursor)
pub fn Editor::insert_string(Self, String, AttrsList?) -> Self
pub fn Editor::new(Buffer) -> Self
pub fn[R : Renderer] Editor::render(Self, R, Color, Color, Color, Color) -> Unit
pub fn Editor::selection(Self) -> Selection
pub fn Editor::selection_bounds(Self) -> (Cursor, Cursor)?
pub fn Editor::set_auto_indent(Self, Bool) -> Self
pub fn Editor::set_cursor(Self, Cursor) -> Self
pub fn Editor::set_selection(Self, Selection) -> Self
pub fn Editor::set_tab_width(Self, Int) -> Self
pub fn Editor::start_change(Self) -> Self
pub fn Editor::tab_width(Self) -> Int

pub(all) enum Family {
  Name(String)
  Serif
  SansSerif
  Cursive
  Fantasy
  Monospace
}
pub impl Eq for Family
pub impl Hash for Family
pub impl Show for Family

type FontCachedCodepointSupportInfo

pub struct FontEntry {
  id : Int
  family_name : String
  postscript_name : String
  font : @moon_swash.FontRef
  charmap_proxy : @moon_swash.CharmapProxy
  attributes : @moon_swash.Attributes
  is_monospace : Bool
  not_emoji : Bool
}
pub fn FontEntry::attributes(Self) -> @moon_swash.Attributes
pub fn FontEntry::charmap_proxy(Self) -> @moon_swash.CharmapProxy
pub fn FontEntry::family_name(Self) -> String
pub fn FontEntry::font(Self) -> @moon_swash.FontRef
pub fn FontEntry::id(Self) -> Int
pub fn FontEntry::is_monospace(Self) -> Bool
pub fn FontEntry::not_emoji(Self) -> Bool
pub fn FontEntry::postscript_name(Self) -> String

pub struct FontMatchAttrs {
  family : Family
  weight : Weight
  stretch : @moon_swash.Stretch
  style : @moon_swash.Style
}
pub impl Eq for FontMatchAttrs
pub impl Hash for FontMatchAttrs

pub struct FontSystem {
  locale : String
  fonts : Array[FontEntry]
  font_matches_cache : @hashmap.HashMap[FontMatchAttrs, Array[Int]]
  codepoint_support_cache : @hashmap.HashMap[Int, FontCachedCodepointSupportInfo]
  shape_run_cache : ShapeRunCache
  // private fields
}
pub fn FontSystem::count_supported_codepoints(Self, Int, Array[UInt]) -> Int
pub fn FontSystem::font_matches(Self, Attrs) -> Array[Int]
pub fn FontSystem::font_matches_for_script(Self, Attrs, @moon_swash.Script) -> Array[Int]
pub fn FontSystem::font_matches_for_scripts(Self, Attrs, Array[@moon_swash.Script]) -> Array[Int]
pub fn FontSystem::fonts(Self) -> Array[FontEntry]
pub fn FontSystem::get_font(Self, Int) -> @moon_swash.FontRef?
pub fn FontSystem::get_font_entry(Self, Int) -> FontEntry?
pub fn FontSystem::load_font_data(Self, Bytes) -> Self
pub fn FontSystem::locale(Self) -> String
pub fn FontSystem::new() -> Self
pub fn FontSystem::new_with_locale(String) -> Self
pub fn FontSystem::resolve(Self, Attrs) -> Int?
pub fn FontSystem::resolve_for_codepoint(Self, Attrs, UInt) -> Int?
pub fn FontSystem::select_family(Self, Family) -> Int?

pub(all) enum Hinting {
  Disabled
  Enabled
}

pub(all) enum Justify {
  Left
  Right
  Center
  Justified
}

pub struct LayoutCursor {
  line : Int
  layout : Int
  glyph : Int
}
pub fn LayoutCursor::new(Int, Int, Int) -> Self
pub impl Eq for LayoutCursor

pub struct LayoutGlyph {
  start : Int
  end : Int
  font_size : Float
  font_id : Int
  font_weight : Int
  glyph_id : Int
  x : Float
  y : Float
  w : Float
  level : Int
  line_height_opt : Float?
  x_offset : Float
  y_offset : Float
  color_opt : Color?
  metadata : Int
  cache_key_flags : UInt
}
pub fn LayoutGlyph::new(Int, Int, Float, Int, Int, Int, Float, Float, Float, Int) -> Self
pub fn LayoutGlyph::physical(Self, (Float, Float), Float) -> PhysicalGlyph

pub struct LayoutLine {
  start : Int
  end : Int
  w : Float
  max_ascent : Float
  max_descent : Float
  line_height_opt : Float?
  glyphs : Array[LayoutGlyph]
}

pub struct LayoutRun {
  line_i : Int
  line_y : Float
  line_top : Float
  line_height : Float
  text : String
  rtl : Bool
  glyphs : Array[LayoutGlyph]
  line_w : Float
}

pub struct LegacyRenderer {
  font_system : FontSystem
  cache : SwashCache
  callback : (Int, Int, UInt, UInt, Color) -> Unit
}
pub fn LegacyRenderer::new(FontSystem, SwashCache, (Int, Int, UInt, UInt, Color) -> Unit) -> Self
pub impl Renderer for LegacyRenderer

pub(all) enum LineBreak {
  NoWrap
  AnyCharacter
  WordBoundary
}

pub(all) enum LineEnding {
  Lf
  CrLf
  Cr
  LfCr
  None
}
pub fn LineEnding::as_str(Self) -> String
pub fn LineEnding::default() -> Self

pub struct LineIter {
  string : String
  start : Int
  end : Int
}
pub fn LineIter::new(String) -> Self
pub fn LineIter::next(Self) -> (Self, (Int, Int, LineEnding)?)

pub struct Metrics {
  font_size : Float
  line_height : Float
}
pub fn Metrics::new(Float, Float) -> Self
pub fn Metrics::relative(Float, Float) -> Self
pub fn Metrics::scale(Self, Float) -> Self

pub(all) enum Motion {
  LayoutCursor(LayoutCursor)
  Previous
  Next
  Left
  Right
  Up
  Down
  Home
  SoftHome
  End
  ParagraphStart
  ParagraphEnd
  PageUp
  PageDown
  Vertical(Int)
  PreviousWord
  NextWord
  LeftWord
  RightWord
  BufferStart
  BufferEnd
  GotoLine(Int)
}
pub impl Eq for Motion

pub struct PhysicalGlyph {
  cache_key : CacheKey
  x : Int
  y : Int
}

pub struct Scroll {
  line : Int
  vertical : Float
  horizontal : Float
}
pub fn Scroll::default() -> Self
pub fn Scroll::new(Int, Float, Float) -> Self

pub(all) enum Selection {
  None
  Normal(Cursor)
  Line(Cursor)
  Word(Cursor)
}
pub impl Eq for Selection

pub struct ShapeGlyph {
  start : Int
  end : Int
  x_advance : Float
  y_advance : Float
  x_offset : Float
  y_offset : Float
  font_id : Int
  font_weight : Int
  glyph_id : Int
  metadata : Int
  level : Int
  metrics_opt : Metrics?
}
pub fn ShapeGlyph::new(Int, Int, Float, Float, Float, Float, Int, Int, Int) -> Self

pub struct ShapeLine {
  rtl : Bool
  glyphs : Array[ShapeGlyph]
}
pub fn ShapeLine::build(Self, String, AttrsList, Shaping, Int) -> Self
pub fn ShapeLine::build_with_font_system(Self, FontSystem, String, AttrsList, Shaping, Int) -> Self
pub fn ShapeLine::empty() -> Self
pub fn ShapeLine::new(Bool, Array[ShapeGlyph]) -> Self

pub struct ShapeRunCache {
  mut age : UInt64
  cache : @hashmap.HashMap[ShapeRunKey, (UInt64, Array[ShapeGlyph])]
}
pub fn ShapeRunCache::clear(Self) -> Unit
pub fn ShapeRunCache::get(Self, ShapeRunKey) -> Array[ShapeGlyph]?
pub fn ShapeRunCache::insert(Self, ShapeRunKey, Array[ShapeGlyph]) -> Unit
pub fn ShapeRunCache::new() -> Self
pub fn ShapeRunCache::peek(Self, ShapeRunKey) -> Array[ShapeGlyph]?
pub fn ShapeRunCache::trim(Self, UInt64) -> Unit
pub impl Show for ShapeRunCache

pub struct ShapeRunKey {
  text : String
  default_attrs : Attrs
  attrs_spans : Array[(Int, Int, Attrs)]
}
pub fn ShapeRunKey::new(String, AttrsList) -> Self
pub impl Eq for ShapeRunKey
pub impl Hash for ShapeRunKey

pub(all) enum Shaping {
  Basic
  Advanced
}

pub enum SubpixelBin {
  Zero
  One
  Two
  Three
}
pub fn SubpixelBin::as_float(Self) -> Float
pub fn SubpixelBin::new(Float) -> (Int, Self)
pub impl Eq for SubpixelBin
pub impl Hash for SubpixelBin
pub impl Show for SubpixelBin

pub struct SwashCache {
  context : @scale.ScaleContext
  image_cache : @hashmap.HashMap[CacheKey, @scale.Image?]
  outline_path_cache : @hashmap.HashMap[CacheKey, (Array[@moon_zeno.Vector], Array[@moon_zeno.Verb])?]
}
pub fn SwashCache::get_image(Self, FontSystem, CacheKey) -> @scale.Image?
pub fn SwashCache::get_image_uncached(Self, FontSystem, CacheKey) -> @scale.Image?
pub fn SwashCache::get_outline_commands(Self, FontSystem, CacheKey) -> (Array[@moon_zeno.Vector], Array[@moon_zeno.Verb])?
pub fn SwashCache::get_outline_commands_uncached(Self, FontSystem, CacheKey) -> (Array[@moon_zeno.Vector], Array[@moon_zeno.Verb])?
pub fn SwashCache::new() -> Self
pub fn SwashCache::with_pixels(Self, FontSystem, CacheKey, Color, (Int, Int, Color) -> Unit) -> Unit

pub struct Weight {
  value : Int
}
pub fn Weight::bold() -> Self
pub fn Weight::new(Int) -> Self
pub fn Weight::normal() -> Self
pub fn Weight::value(Self) -> Int
pub impl Eq for Weight
pub impl Hash for Weight
pub impl Show for Weight

pub(all) enum Wrap {
  None
  Glyph
  Word
  WordOrGlyph
}

// Type aliases
pub type CacheKeyFlags = UInt

// Traits
pub(open) trait Renderer {
  rectangle(Self, Int, Int, UInt, UInt, Color) -> Unit
  glyph(Self, PhysicalGlyph, Color) -> Unit
}

